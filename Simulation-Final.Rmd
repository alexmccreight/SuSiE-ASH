---
title: "Simulation-Final"
output: html_document
date: "2024-04-07"
---

```{r, include = F}
# Load Libraries
library(tidyverse)
library(mr.ash.alpha)
library(susieR)
library(FamilyRank)

# Fix File path later
devtools::load_all('/Users/alexmccreight/Columbia/Research/SuSiE-ASH/SuSiE-ASH/submodules/susieR')
devtools::load_all('/Users/alexmccreight/Columbia/Research/SuSiE-ASH/SuSiE-ASH/submodules/mr.ash.alpha')

# SuSiE-ASH (v2; Gao's Version)
source("/Users/alexmccreight/Columbia/Research/SuSiE-ASH/SuSiE-ASH/code/SuSiE-ASH-Versions/susie-ash-warmstart-v2.R")
```

```{r}
generate_data <- function(X, total_heritability, sparse_effects, nonsparse_coverage, ratio) {
  n <- nrow(X)
  p <- ncol(X)
  
  # Generate sparse effects (beta.true)
  beta.true <- rep(0, p)
  beta.true[sample(p, sparse_effects)] <- rnorm(sparse_effects, mean = 0, sd = 0.5)
  
  # Generate nonsparse effects (theta.true)
  num_nonsparse <- round(p * nonsparse_coverage)
  theta.true <- rep(0, p)
  theta.true[sample(p, num_nonsparse)] <- rnorm(num_nonsparse, mean = 0, sd = 0.01)
  
  # Scale the genotype matrix
  X <- scale(X, center = TRUE, scale = FALSE)
  
  # Calculate the variance of the sparse and nonsparse effects
  var_beta <- var(X %*% beta.true)
  var_theta <- var(X %*% theta.true)
  
  # Adjust the effect sizes based on the theta_beta_ratio
  ratio_factor <- (ratio * var_beta) / var_theta
  theta.true <- theta.true * sqrt(ratio_factor)
  
  # Recalculate the variance of the adjusted nonsparse effects
  var_theta_adjusted <- var(X %*% theta.true)
  
  # Calculate the residual variance based on the total heritability
  sigmasq_error <- (var_beta + var_theta_adjusted) * (1 - total_heritability) / total_heritability
  
  # Create Outcomes
  y <- X %*% matrix(beta.true, ncol = 1) + X %*% matrix(theta.true, ncol = 1) + rnorm(n, 0, sqrt(sigmasq_error))
  y <- scale(y, center = TRUE, scale = FALSE)
  
  # Store Information
  return(list(y = y, error = sigmasq_error, beta = beta.true, theta = theta.true))
}

data <- generate_data(X = X[[20]], total_heritability = 0.25, sparse_effects = 3, nonsparse_coverage = 0.1, ratio = 0.5)

plot(data$beta, ylim = c(-2.5,2.5), ylab = "beta")
plot(data$theta, ylim = c(-1.5,1.5), ylab = "theta")
```



```{r}
method_and_score <- function(X = data$X, y = data$y, beta = data$beta, theta = data$theta, L = 10, threshold = 0.9) {
  # Run various methods
  susie_output <- susie(X = X, y = y, L = L)
  susie_ash_output <- susie_ash_warmstart(X = X, y = y, L = L, warm_start = 5, tol = 0.03)
  
  calc_metrics_susie <- function(mod, beta = data$beta, theta = data$theta, threshold = 0.9) {
    # Identify causal variables (non-zero sparse/non-sparse effects)
    all_causal <- c(which(beta != 0), which(theta != 0))
    sparse_causal <- which(beta != 0)
    significant <- mod$pip > threshold
    
    # Calculate Average CS Size
    cs_size <- length(unlist(susie_get_cs(mod, X = data$X, coverage = threshold)$cs)) / length(susie_get_cs(mod, X = data$X, coverage = threshold)$cs)
    
    # Calculate Coverage (proportion of cs with all causal effect)
    coverage <- sum((all_causal) %in% susie_get_cs(mod, X = data$X, coverage = threshold)$cs) / length(susie_get_cs(mod, X = data$X, coverage = threshold)$cs)
    
      # CS Based FDR
     test.cs <- susie_get_cs(mod, X = data$X, coverage = threshold)$cs
    
      TP = sum(all_causal %in% unlist(test.cs))
      FN = length(all_causal) - TP
      FP = length(test.cs) - lapply(1:length(test.cs), function(cs.l){ ifelse(sum(test.cs[[cs.l]] %in% all_causal)!=0,T,F)}) %>% unlist(.) %>% sum(.) # FP based on CSs

      cs_fdr = FP/(TP+FP)
      
      # CS Based Recall
      TP = sum(sparse_causal %in% unlist(test.cs))
      FN = length(sparse_causal) - TP
      FP = length(test.cs) - lapply(1:length(test.cs), function(cs.l){ ifelse(sum(test.cs[[cs.l]] %in% sparse_causal)!=0,T,F)}) %>% unlist(.) %>% sum(.) 
      
      cs_recall = TP/(TP+FN)

    
    return(list(cs_fdr = cs_fdr, cs_recall = cs_recall, cs_size = cs_size, coverage = coverage))
  }
  
  # Need to adjust size threshold
  calc_metrics_susie_ash <- function(mod, beta = data$beta, theta = data$theta, threshold = 0.9) {
    # Identify causal variables (non-zero sparse/non-sparse effects)
    all_causal <- c(which(beta != 0), which(theta != 0))
    sparse_causal <- which(beta != 0)
    significant <- mod$pip > threshold
    
    # Calculate Average CS Size
    cs_size <- length(unlist(susie_get_cs_attainable(mod, coverage = threshold))) / length(susie_get_cs_attainable(mod, coverage = threshold))
    
    # Calculate Coverage (proportion of cs with all causal effect)
    coverage <- sum(all_causal %in% susie_get_cs_attainable(mod, coverage = threshold)) / length(susie_get_cs_attainable(mod, coverage = threshold))
    
      # CS Based FDR
     test.cs <- susie_get_cs_attainable(mod, coverage = threshold)
    
      TP = sum(all_causal %in% unlist(test.cs))
      FN = length(all_causal) - TP
      FP = length(test.cs) - lapply(1:length(test.cs), function(cs.l){ ifelse(sum(test.cs[[cs.l]] %in% all_causal)!=0,T,F)}) %>% unlist(.) %>% sum(.) # FP based on CSs

      cs_fdr = FP/(TP+FP)
      
      # CS Based Recall
      TP = sum(sparse_causal %in% unlist(test.cs))
      FN = length(sparse_causal) - TP
      FP = length(test.cs) - lapply(1:length(test.cs), function(cs.l){ ifelse(sum(test.cs[[cs.l]] %in% sparse_causal)!=0,T,F)}) %>% unlist(.) %>% sum(.) 
      
      cs_recall = TP/(TP+FN)

    
    return(list(cs_fdr = cs_fdr, cs_recall = cs_recall, cs_size = cs_size, coverage = coverage))
  }
  
  # Calculate FDR and Recall for each method
  susie_metrics <- calc_metrics(susie_output, beta, theta, threshold)
  susie_ash_output <- calc_metrics_susie_ash(susie_ash_output, beta, theta, threshold)
  
  #Create a data frame with the results
  metrics_table  <- data.frame(
    Model = c("SuSiE", "SuSiE-ASH"),
    CS_FDR = c(susie_metrics$cs_fdr, susie_ash_output$cs_fdr), # all non-zero = causal
    CS_Recall = c(susie_metrics$cs_recall, susie_ash_output$cs_recall), # only sparse = causal
    CS_Size = c(susie_metrics$cs_size, susie_ash_output$cs_size),
    Coverage = c(susie_metrics$coverage, susie_ash_output$coverage),
  )
  # Return the results table
  return(list(
    metrics = metrics_table,
    susie_output = susie_output,
    susie_ash_output = susie_ash_output,
    betas = data$beta,
    thetas = data$theta)
  )
}
```


